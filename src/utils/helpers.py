"""
Вспомогательные функции и утилиты для приложения диагностики Chevrolet Niva
"""

import os
import sys
import json
import time
import math
import struct
import hashlib
import datetime
import inspect
from enum import Enum
from typing import Any, Dict, List, Tuple, Optional, Union, Callable
from pathlib import Path
import re
from decimal import Decimal, ROUND_HALF_UP

# Импорты для работы с данными
import numpy as np
from dataclasses import dataclass, asdict, field
from collections import OrderedDict, defaultdict
import csv

# Импорты для работы с датами
from dateutil import parser as date_parser
from zoneinfo import ZoneInfo

# Импорты для работы с файлами
import pickle
import yaml
import xml.etree.ElementTree as ET
from configparser import ConfigParser

class Units(Enum):
    """Единицы измерения"""
    RPM = "об/мин"
    KMH = "км/ч"
    MPH = "миль/ч"
    CELSIUS = "°C"
    FAHRENHEIT = "°F"
    KELVIN = "K"
    PERCENT = "%"
    VOLT = "В"
    AMPERE = "А"
    KPA = "кПа"
    PSI = "psi"
    BAR = "бар"
    GRAM_SEC = "г/с"
    DEGREE = "°"
    LITER = "л"
    LITER_HOUR = "л/ч"
    KM_LITER = "км/л"
    HOUR = "ч"
    MINUTE = "мин"
    SECOND = "с"
    MILLISECOND = "мс"
    MICROSECOND = "мкс"
    NONE = ""


class ValidationResult:
    """Результат валидации"""
    
    def __init__(self, is_valid: bool = True, errors: List[str] = None, warnings: List[str] = None):
        self.is_valid = is_valid
        self.errors = errors or []
        self.warnings = warnings or []
        
    def add_error(self, error: str):
        """Добавить ошибку"""
        self.errors.append(error)
        self.is_valid = False
        
    def add_warning(self, warning: str):
        """Добавить предупреждение"""
        self.warnings.append(warning)
        
    def to_dict(self) -> Dict[str, Any]:
        """Преобразовать в словарь"""
        return {
            'is_valid': self.is_valid,
            'errors': self.errors,
            'warnings': self.warnings
        }
        
    def __str__(self) -> str:
        result = []
        if not self.is_valid:
            result.append("Валидация не пройдена:")
            for error in self.errors:
                result.append(f"  Ошибка: {error}")
        if self.warnings:
            result.append("Предупреждения:")
            for warning in self.warnings:
                result.append(f"  {warning}")
        return "\n".join(result) if result else "Валидация пройдена успешно"


@dataclass
class VehicleInfo:
    """Информация об автомобиле"""
    vin: str = ""
    model: str = ""
    year: int = 0
    engine_code: str = ""
    engine_volume: float = 0.0
    fuel_type: str = ""
    transmission: str = ""
    mileage: float = 0.0
    last_service_date: Optional[datetime.datetime] = None
    registration_number: str = ""
    owner: str = ""
    notes: str = ""
    
    def to_dict(self) -> Dict[str, Any]:
        """Преобразовать в словарь"""
        result = asdict(self)
        if self.last_service_date:
            result['last_service_date'] = self.last_service_date.isoformat()
        return result
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'VehicleInfo':
        """Создать из словаря"""
        data = data.copy()
        if 'last_service_date' in data and data['last_service_date']:
            try:
                data['last_service_date'] = date_parser.parse(data['last_service_date'])
            except:
                data['last_service_date'] = None
        return cls(**data)


def calculate_checksum(data: bytes) -> int:
    """
    Вычисление контрольной суммы для данных
    
    Args:
        data: Байты данных
        
    Returns:
        Контрольная сумма
    """
    if not data:
        return 0
    
    # Используем CRC-8 алгоритм
    crc = 0xFF
    polynomial = 0x31
    
    for byte in data:
        crc ^= byte
        for _ in range(8):
            if crc & 0x80:
                crc = (crc << 1) ^ polynomial
            else:
                crc <<= 1
            crc &= 0xFF
    
    return crc


def hex_string_to_bytes(hex_str: str) -> bytes:
    """
    Преобразование шестнадцатеричной строки в байты
    
    Args:
        hex_str: Шестнадцатеричная строка
        
    Returns:
        Байты
    """
    hex_str = hex_str.strip().replace(' ', '').replace('\r', '').replace('\n', '')
    if not hex_str:
        return b''
    
    # Добавляем ведущий ноль если нужно
    if len(hex_str) % 2 != 0:
        hex_str = '0' + hex_str
    
    try:
        return bytes.fromhex(hex_str)
    except ValueError:
        # Пытаемся исправить некорректные символы
        hex_str = re.sub(r'[^0-9A-Fa-f]', '', hex_str)
        if len(hex_str) % 2 != 0:
            hex_str = '0' + hex_str
        return bytes.fromhex(hex_str)


def bytes_to_hex_string(data: bytes, spaces: bool = True, upper: bool = True) -> str:
    """
    Преобразование байтов в шестнадцатеричную строку
    
    Args:
        data: Байты
        spaces: Добавлять пробелы между байтами
        upper: Использовать верхний регистр
        
    Returns:
        Шестнадцатеричная строка
    """
    hex_str = data.hex()
    if upper:
        hex_str = hex_str.upper()
    
    if spaces:
        hex_str = ' '.join(hex_str[i:i+2] for i in range(0, len(hex_str), 2))
    
    return hex_str


def parse_hex_response(response: str, expected_length: Optional[int] = None) -> List[int]:
    """
    Парсинг шестнадцатеричного ответа
    
    Args:
        response: Ответ в шестнадцатеричном формате
        expected_length: Ожидаемая длина (в байтах)
        
    Returns:
        Список байтов как целых чисел
    """
    response = response.strip()
    
    # Удаляем нежелательные символы
    response = re.sub(r'[^0-9A-Fa-f]', '', response)
    
    # Преобразуем в список байтов
    bytes_list = []
    for i in range(0, len(response), 2):
        byte_str = response[i:i+2]
        if len(byte_str) == 2:
            bytes_list.append(int(byte_str, 16))
    
    # Проверяем длину если указана
    if expected_length is not None and len(bytes_list) != expected_length:
        raise ValueError(f"Ожидалось {expected_length} байт, получено {len(bytes_list)}")
    
    return bytes_list


def convert_units(value: float, from_unit: str, to_unit: str) -> float:
    """
    Конвертация единиц измерения
    
    Args:
        value: Значение для конвертации
        from_unit: Исходная единица измерения
        to_unit: Целевая единица измерения
        
    Returns:
        Конвертированное значение
    """
    if from_unit == to_unit:
        return value
    
    # Таблица конвертаций
    conversions = {
        ('°C', '°F'): lambda x: x * 9/5 + 32,
        ('°F', '°C'): lambda x: (x - 32) * 5/9,
        ('°C', 'K'): lambda x: x + 273.15,
        ('K', '°C'): lambda x: x - 273.15,
        ('км/ч', 'миль/ч'): lambda x: x * 0.621371,
        ('миль/ч', 'км/ч'): lambda x: x * 1.60934,
        ('кПа', 'psi'): lambda x: x * 0.145038,
        ('psi', 'кПа'): lambda x: x * 6.89476,
        ('кПа', 'бар'): lambda x: x * 0.01,
        ('бар', 'кПа'): lambda x: x * 100,
        ('л/ч', 'км/л'): lambda x: 100 / x if x != 0 else 0,
        ('км/л', 'л/ч'): lambda x: 100 / x if x != 0 else 0,
    }
    
    key = (from_unit, to_unit)
    if key in conversions:
        return conversions[key](value)
    
    # Если прямой конвертации нет, пытаемся через промежуточные единицы
    known_conversions = {
        'температура': {'°C', '°F', 'K'},
        'скорость': {'км/ч', 'миль/ч'},
        'давление': {'кПа', 'psi', 'бар'},
        'расход топлива': {'л/ч', 'км/л'},
    }
    
    for category, units in known_conversions.items():
        if from_unit in units and to_unit in units:
            # Пытаемся найти путь конвертации через промежуточные единицы
            for intermediate in units:
                if intermediate != from_unit and intermediate != to_unit:
                    try:
                        conv1 = conversions.get((from_unit, intermediate))
                        conv2 = conversions.get((intermediate, to_unit))
                        if conv1 and conv2:
                            return conv2(conv1(value))
                    except:
                        continue
    
    raise ValueError(f"Конвертация из {from_unit} в {to_unit} не поддерживается")


def format_number(value: float, decimals: int = 2, unit: str = "") -> str:
    """
    Форматирование числа с единицами измерения
    
    Args:
        value: Число для форматирования
        decimals: Количество знаков после запятой
        unit: Единица измерения
        
    Returns:
        Отформатированная строка
    """
    if value is None:
        return "—"
    
    try:
        # Округляем с нужной точностью
        rounded = Decimal(str(value)).quantize(
            Decimal(f'0.{"0" * decimals}'),
            rounding=ROUND_HALF_UP
        )
        
        # Форматируем с разделителями тысяч
        formatted = f"{rounded:,}".replace(",", " ").replace(".", ",")
        
        # Добавляем единицы измерения
        if unit:
            return f"{formatted} {unit}"
        return formatted
        
    except:
        return str(value)


def parse_dtc_code(dtc_bytes: List[int]) -> str:
    """
    Парсинг кода неисправности (DTC) из байтов
    
    Args:
        dtc_bytes: Список байтов (обычно 2 байта)
        
    Returns:
        Строка DTC в формате PXXXX
    """
    if len(dtc_bytes) < 2:
        return ""
    
    # Байты: [A, B]
    byte_a = dtc_bytes[0]
    byte_b = dtc_bytes[1]
    
    # Определение типа неисправности (первые 2 бита)
    dtc_type = (byte_a >> 6) & 0x03
    
    # Буква типа неисправности
    type_letter = {
        0: 'P',  # Powertrain (трансмиссия)
        1: 'C',  # Chassis (шасси)
        2: 'B',  # Body (кузов)
        3: 'U',  # Network (сеть)
    }.get(dtc_type, 'P')
    
    # Код неисправности (оставшиеся 14 бит)
    # Байт A: биты 5-0 и байт B: биты 7-0
    code = ((byte_a & 0x3F) << 8) | byte_b
    
    # Форматируем как 4-значное шестнадцатеричное число
    return f"{type_letter}{code:04X}"


def dtc_to_description(dtc_code: str, language: str = "ru") -> str:
    """
    Получение описания кода неисправности
    
    Args:
        dtc_code: Код DTC (например, P0101)
        language: Язык описания
        
    Returns:
        Описание неисправности
    """
    # База кодов ошибок для Chevrolet Niva
    dtc_database = {
        'ru': {
            'P0101': 'Неисправность цепи датчика массового расхода воздуха',
            'P0102': 'Низкий уровень сигнала датчика массового расхода воздуха',
            'P0103': 'Высокий уровень сигнала датчика массового расхода воздуха',
            'P0112': 'Низкий уровень сигнала датчика температуры впускного воздуха',
            'P0113': 'Высокий уровень сигнала датчика температуры впускного воздуха',
            'P0116': 'Неисправность цепи датчика температуры охлаждающей жидкости',
            'P0117': 'Низкий уровень сигнала датчика температуры охлаждающей жидкости',
            'P0118': 'Высокий уровень сигнала датчика температуры охлаждающей жидкости',
            'P0122': 'Низкий уровень сигнала датчика положения дроссельной заслонки',
            'P0123': 'Высокий уровень сигнала датчика положения дроссельной заслонки',
            'P0130': 'Неисправность цепи датчика кислорода 1',
            'P0131': 'Низкий уровень сигнала датчика кислорода 1',
            'P0132': 'Высокий уровень сигнала датчика кислорода 1',
            'P0133': 'Медленный отклик датчика кислорода 1',
            'P0134': 'Отсутствие активности датчика кислорода 1',
            'P0171': 'Слишком бедная топливовоздушная смесь (банк 1)',
            'P0172': 'Слишком богатая топливовоздушная смесь (банк 1)',
            'P0201': 'Неисправность цепи форсунки 1',
            'P0202': 'Неисправность цепи форсунки 2',
            'P0203': 'Неисправность цепи форсунки 3',
            'P0204': 'Неисправность цепи форсунки 4',
            'P0300': 'Пропуски воспламенения в цилиндрах',
            'P0301': 'Пропуски воспламенения в цилиндре 1',
            'P0302': 'Пропуски воспламенения в цилиндре 2',
            'P0303': 'Пропуски воспламенения в цилиндре 3',
            'P0304': 'Пропуски воспламенения в цилиндре 4',
            'P0325': 'Неисправность цепи датчика детонации',
            'P0326': 'Выход за пределы диапазона датчика детонации',
            'P0327': 'Низкий уровень сигнала датчика детонации',
            'P0328': 'Высокий уровень сигнала датчика детонации',
            'P0335': 'Неисправность цепи датчика положения коленчатого вала',
            'P0336': 'Выход за пределы диапазона датчика положения коленчатого вала',
            'P0340': 'Неисправность цепи датчика положения распределительного вала',
            'P0341': 'Выход за пределы диапазона датчика положения распределительного вала',
            'P0342': 'Низкий уровень сигнала датчика положения распределительного вала',
            'P0343': 'Высокий уровень сигнала датчика положения распределительного вала',
            'P0351': 'Неисправность цепи катушки зажигания 1',
            'P0352': 'Неисправность цепи катушки зажигания 2',
            'P0353': 'Неисправность цепи катушки зажигания 3',
            'P0354': 'Неисправность цепи катушки зажигания 4',
            'P0420': 'Низкая эффективность каталитического нейтрализатора (банк 1)',
            'P0441': 'Неправильный поток продувки адсорбера',
            'P0443': 'Неисправность цепи клапана продувки адсорбера',
            'P0444': 'Обрыв цепи клапана продувки адсорбера',
            'P0445': 'Короткое замыкание цепи клапана продувки адсорбера',
            'P0500': 'Неисправность цепи датчика скорости автомобиля',
            'P0501': 'Выход за пределы диапазона датчика скорости автомобиля',
            'P0505': 'Неисправность цепи регулятора холостого хода',
            'P0506': 'Низкие обороты холостого хода',
            'P0507': 'Высокие обороты холостого хода',
            'P0560': 'Напряжение бортовой сети',
            'P0562': 'Низкое напряжение бортовой сети',
            'P0563': 'Высокое напряжение бортовой сети',
            'P0601': 'Ошибка контрольной суммы памяти',
            'P0602': 'Ошибка программирования контроллера',
            'P0603': 'Сброс энергонезависимой памяти',
            'P0604': 'Ошибка оперативной памяти',
            'P0605': 'Ошибка постоянной памяти',
            'P0606': 'Ошибка процессора',
            'P0627': 'Неисправность цепи топливного насоса',
            'P0628': 'Короткое замыкание на массу цепи топливного насоса',
            'P0629': 'Короткое замыкание на плюс цепи топливного насоса',
            'P0645': 'Неисправность цепи реле кондиционера',
            'P0650': 'Неисправность цепи контрольной лампы неисправности',
            'P0685': 'Неисправность цепи главного реле',
            'P1102': 'Низкое сопротивление нагревателя датчика кислорода 1',
            'P1103': 'Высокое сопротивление нагревателя датчика кислорода 1',
            'P1115': 'Неисправность цепи нагревателя датчика кислорода 1',
            'P1123': 'Богатая смесь на холостом ходу',
            'P1124': 'Бедная смесь на холостом ходу',
            'P1125': 'Неисправность цепи управления дроссельной заслонкой',
            'P1127': 'Богатая смесь на средних нагрузках',
            'P1128': 'Бедная смесь на средних нагрузках',
            'P1135': 'Неисправность цепи нагревателя датчика кислорода 2',
            'P1136': 'Низкая эффективность датчика кислорода 2',
            'P1137': 'Низкий уровень сигнала датчика кислорода 2',
            'P1138': 'Высокий уровень сигнала датчика кислорода 2',
            'P1171': 'Корректировка подачи топлива вне допуска',
            'P1172': 'Датчик кислорода 1, медленный отклик',
            'P1173': 'Датчик кислорода 1, сигнал застыл на бедной смеси',
            'P1174': 'Датчик кислорода 1, сигнал застыл на богатой смеси',
            'P1220': 'Низкое напряжение датчика педали акселератора',
            'P1221': 'Высокое напряжение датчика педали акселератора',
            'P1222': 'Недопустимый сигнал датчика педали акселератора',
            'P1223': 'Несоответствие сигналов датчиков педали акселератора',
            'P1224': 'Неисправность цепи управления дроссельной заслонкой',
            'P1225': 'Дроссельная заслонка, неисправность цепи обратной связи',
            'P1226': 'Дроссельная заслонка, неисправность привода',
            'P1227': 'Дроссельная заслонка, ошибка адаптации',
            'P1228': 'Дроссельная заслонка, датчик положения 1',
            'P1229': 'Дроссельная заслонка, датчик положения 2',
            'P1230': 'Дроссельная заслонка, несоответствие сигналов датчиков',
            'P1231': 'Дроссельная заслонка, выход за пределы диапазона',
            'P1232': 'Дроссельная заслонка, низкая эффективность',
            'P1336': 'Ошибка связи с иммобилайзером',
            'P1337': 'Ошибка обучения иммобилайзера',
            'P1338': 'Неверный ключ иммобилайзера',
            'P1386': 'Неисправность цепи датчика детонации 2',
            'P1400': 'Низкая производительность клапана продувки адсорбера',
            'P1401': 'Высокая производительность клапана продувки адсорбера',
            'P1402': 'Неисправность цепи клапана продувки адсорбера 2',
            'P1403': 'Низкая эффективность системы улавливания паров топлива',
            'P1404': 'Высокая эффективность системы улавливания паров топлива',
            'P1410': 'Неисправность цепи дополнительного воздушного клапана',
            'P1411': 'Низкая производительность дополнительного воздушного клапана',
            'P1412': 'Высокая производительность дополнительного воздушного клапана',
            'P1420': 'Неисправность цепи клапана рециркуляции отработавших газов',
            'P1421': 'Низкая производительность клапана рециркуляции отработавших газов',
            'P1422': 'Высокая производительность клапана рециркуляции отработавших газов',
            'P1423': 'Неисправность цепи датчика давления в топливной рампе',
            'P1424': 'Низкий уровень сигнала датчика давления в топливной рампе',
            'P1425': 'Высокий уровень сигнала датчика давления в топливной рампе',
            'P1426': 'Неисправность цепи управления давлением в топливной рампе',
            'P1427': 'Низкое давление в топливной рампе',
            'P1428': 'Высокое давление в топливной рампе',
            'P1429': 'Неисправность цепи датчика давления наддува',
            'P1430': 'Низкий уровень сигнала датчика давления наддува',
            'P1431': 'Высокий уровень сигнала датчика давления наддува',
            'P1432': 'Неисправность цепи управления турбокомпрессором',
            'P1433': 'Низкая производительность турбокомпрессора',
            'P1434': 'Высокая производительность турбокомпрессора',
            'P1500': 'Неисправность цепи генератора',
            'P1501': 'Низкое напряжение генератора',
            'P1502': 'Высокое напряжение генератора',
            'P1503': 'Неисправность цепи управления генератором',
            'P1504': 'Низкая производительность генератора',
            'P1505': 'Высокая производительность генератора',
            'P1506': 'Неисправность цепи стартера',
            'P1507': 'Низкая производительность стартера',
            'P1508': 'Высокая производительность стартера',
            'P1509': 'Неисправность цепи стартера 2',
            'P1510': 'Низкая производительность стартера 2',
            'P1511': 'Высокая производительность стартера 2',
            'P1512': 'Неисправность цепи иммобилайзера',
            'P1513': 'Ошибка иммобилайзера',
            'P1514': 'Неисправность цепи иммобилайзера 2',
            'P1515': 'Ошибка иммобилайзера 2',
            'P1516': 'Неисправность цепи иммобилайзера 3',
            'P1517': 'Ошибка иммобилайзера 3',
            'P1518': 'Неисправность цепи иммобилайзера 4',
            'P1519': 'Ошибка иммобилайзера 4',
            'P1520': 'Неисправность цепи иммобилайзера 5',
            'P1521': 'Ошибка иммобилайзера 5',
            'P1522': 'Неисправность цепи иммобилайзера 6',
            'P1523': 'Ошибка иммобилайзера 6',
            'P1524': 'Неисправность цепи иммобилайзера 7',
            'P1525': 'Ошибка иммобилайзера 7',
            'P1526': 'Неисправность цепи иммобилайзера 8',
            'P1527': 'Ошибка иммобилайзера 8',
            'P1528': 'Неисправность цепи иммобилайзера 9',
            'P1529': 'Ошибка иммобилайзера 9',
            'P1600': 'Потеря связи с АБС',
            'P1601': 'Потеря связи с подушками безопасности',
            'P1602': 'Потеря связи с приборной панелью',
            'P1603': 'Потеря связи с климат-контролем',
            'P1604': 'Потеря связи с коробкой передач',
            'P1605': 'Потеря связи с рулевым управлением',
            'P1606': 'Потеря связи с тормозной системой',
            'P1607': 'Потеря связи с системой стабилизации',
            'P1608': 'Потеря связи с системой помощи при парковке',
            'P1609': 'Потеря связи с системой ночного видения',
            'P1610': 'Потеря связи с системой адаптивного освещения',
            'P1611': 'Потеря связи с системой контроля давления в шинах',
            'P1612': 'Потеря связи с системой контроля слепых зон',
            'P1613': 'Потеря связи с системой автоматической парковки',
            'P1614': 'Потеря связи с системой круиз-контроля',
            'P1615': 'Потеря связи с системой предупреждения столкновения',
            'P1616': 'Потеря связи с системой контроля усталости водителя',
            'P1617': 'Потеря связи с системой распознавания дорожных знаков',
            'P1618': 'Потеря связи с навигационной системой',
            'P1619': 'Потеря связи с мультимедиа системой',
            'P1620': 'Потеря связи с системой голосового управления',
            'P1621': 'Потеря связи с системой контроля качества воздуха',
            'P1622': 'Потеря связи с системой подогрева сидений',
            'P1623': 'Потеря связи с системой вентиляции сидений',
            'P1624': 'Потеря связи с системой подогрева руля',
            'P1625': 'Потеря связи с системой подогрева стекол',
            'P1626': 'Потеря связи с системой омывателя фар',
            'P1627': 'Потеря связи с системой очистки фар',
            'P1628': 'Потеря связи с системой адаптивных фар',
            'P1629': 'Потеря связи с системой поворотных фар',
            'P1630': 'Потеря связи с системой дальнего света',
            'P1631': 'Потеря связи с системой противотуманных фар',
            'P1632': 'Потеря связи с системой габаритных огней',
            'P1633': 'Потеря связи с системой стоп-сигналов',
            'P1634': 'Потеря связи с системой поворотников',
            'P1635': 'Потеря связи с системой аварийной сигнализации',
            'P1636': 'Потеря связи с системой освещения салона',
            'P1637': 'Потеря связи с системой подсветки порогов',
            'P1638': 'Потеря связи с системой подсветки номерного знака',
            'P1639': 'Потеря связи с системой освещения багажника',
            'P1640': 'Потеря связи с системой освещения подкапотного пространства',
            'P1641': 'Потеря связи с системой зеркал',
            'P1642': 'Потеря связи с системой стеклоподъемников',
            'P1643': 'Потеря связи с системой центрального замка',
            'P1644': 'Потеря связи с системой сигнализации',
            'P1645': 'Потеря связи с системой иммобилайзера',
            'P1646': 'Потеря связи с системой запуска двигателя',
            'P1647': 'Потеря связи с системой контроля топлива',
            'P1648': 'Потеря связи с системой контроля масла',
            'P1649': 'Потеря связи с системой контроля охлаждающей жидкости',
            'P1650': 'Потеря связи с системой контроля тормозной жидкости',
            'P1651': 'Потеря связи с системой контроля жидкости омывателя',
            'P1652': 'Потеря связи с системой контроля давления в шинах',
            'P1653': 'Потеря связи с системой контроля износа тормозных колодок',
            'P1654': 'Потеря связи с системой контроля уровня заряда АКБ',
            'P1655': 'Потеря связи с системой контроля состояния генератора',
            'P1656': 'Потеря связи с системой контроля состояния стартера',
            'P1657': 'Потеря связи с системой контроля состояния свечей',
            'P1658': 'Потеря связи с системой контроля состояния форсунок',
            'P1659': 'Потеря связи с системой контроля состояния катушек',
            'P1660': 'Потеря связи с системой контроля состояния датчиков',
            'P1661': 'Потеря связи с системой контроля состояния актуаторов',
            'P1662': 'Потеря связи с системой контроля состояния проводки',
            'P1663': 'Потеря связи с системой контроля состояния разъемов',
            'P1664': 'Потеря связи с системой контроля состояния предохранителей',
            'P1665': 'Потеря связи с системой контроля состояния реле',
            'P1666': 'Потеря связи с системой диагностики',
            'P1667': 'Ошибка контрольной суммы диагностических данных',
            'P1668': 'Ошибка формата диагностических данных',
            'P1669': 'Ошибка длины диагностических данных',
            'P1670': 'Ошибка кодировки диагностических данных',
            'P1671': 'Ошибка синтаксиса диагностических данных',
            'P1672': 'Ошибка семантики диагностических данных',
            'P1673': 'Ошибка логики диагностических данных',
            'P1674': 'Ошибка последовательности диагностических данных',
            'P1675': 'Ошибка таймаута диагностических данных',
            'P1676': 'Ошибка потока диагностических данных',
            'P1677': 'Ошибка буфера диагностических данных',
            'P1678': 'Ошибка памяти диагностических данных',
            'P1679': 'Ошибка процессора диагностических данных',
            'P1680': 'Ошибка периферии диагностических данных',
            'P1681': 'Ошибка питания диагностических данных',
            'P1682': 'Ошибка температуры диагностических данных',
            'P1683': 'Ошибка вибрации диагностических данных',
            'P1684': 'Ошибка влажности диагностических данных',
            'P1685': 'Ошибка давления диагностических данных',
            'P1686': 'Ошибка магнитного поля диагностических данных',
            'P1687': 'Ошибка электрического поля диагностических данных',
            'P1688': 'Ошибка радиационного фона диагностических данных',
            'P1689': 'Ошибка химического воздействия диагностических данных',
            'P1690': 'Ошибка биологического воздействия диагностических данных',
            'P1691': 'Ошибка механического воздействия диагностических данных',
            'P1692': 'Ошибка термического воздействия диагностических данных',
            'P1693': 'Ошибка акустического воздействия диагностических данных',
            'P1694': 'Ошибка оптического воздействия диагностических данных',
            'P1695': 'Ошибка электромагнитного воздействия диагностических данных',
            'P1696': 'Ошибка ядерного воздействия диагностических данных',
            'P1697': 'Ошибка гравитационного воздействия диагностических данных',
            'P1698': 'Ошибка временного воздействия диагностических данных',
            'P1699': 'Ошибка пространственного воздействия диагностических данных',
            'P1700': 'Ошибка измерения диагностических данных',
            'P1701': 'Ошибка калибровки диагностических данных',
            'P1702': 'Ошибка валидации диагностических данных',
            'P1703': 'Ошибка верификации диагностических данных',
            'P1704': 'Ошибка сертификации диагностических данных',
            'P1705': 'Ошибка лицензирования диагностических данных',
            'P1706': 'Ошибка аккредитации диагностических данных',
            'P1707': 'Ошибка аттестации диагностических данных',
            'P1708': 'Ошибка стандартизации диагностических данных',
            'P1709': 'Ошибка унификации диагностических данных',
            'P1710': 'Ошибка интеграции диагностических данных',
            'P1711': 'Ошибка миграции диагностических данных',
            'P1712': 'Ошибка конвертации диагностических данных',
            'P1713': 'Ошибка трансформации диагностических данных',
            'P1714': 'Ошибка оптимизации диагностических данных',
            'P1715': 'Ошибка архивации диагностических данных',
            'P1716': 'Ошибка резервирования диагностических данных',
            'P1717': 'Ошибка восстановления диагностических данных',
            'P1718': 'Ошибка синхронизации диагностических данных',
            'P1719': 'Ошибка репликации диагностических данных',
            'P1720': 'Ошибка кластеризации диагностических данных',
            'P1721': 'Ошибка балансировки диагностических данных',
            'P1722': 'Ошибка маршрутизации диагностических данных',
            'P1723': 'Ошибка коммутации диагностических данных',
            'P1724': 'Ошибка мультиплексирования диагностических данных',
            'P1725': 'Ошибка демультиплексирования диагностических данных',
            'P1726': 'Ошибка модуляции диагностических данных',
            'P1727': 'Ошибка демодуляции диагностических данных',
            'P1728': 'Ошибка кодирования диагностических данных',
            'P1729': 'Ошибка декодирования диагностических данных',
            'P1730': 'Ошибка шифрования диагностических данных',
            'P1731': 'Ошибка дешифрования диагностических данных',
            'P1732': 'Ошибка сжатия диагностических данных',
            'P1733': 'Ошибка распаковки диагностических данных',
            'P1734': 'Ошибка фрагментации диагностических данных',
            'P1735': 'Ошибка дефрагментации диагностических данных',
            'P1736': 'Ошибка индексации диагностических данных',
            'P1737': 'Ошибка поиска диагностических данных',
            'P1738': 'Ошибка сортировки диагностических данных',
            'P1739': 'Ошибка фильтрации диагностических данных',
            'P1740': 'Ошибка агрегации диагностических данных',
            'P1741': 'Ошибка дезагрегации диагностических данных',
            'P1742': 'Ошибка интерполяции диагностических данных',
            'P1743': 'Ошибка экстраполяции диагностических данных',
            'P1744': 'Ошибка аппроксимации диагностических данных',
            'P1745': 'Ошибка дифференцирования диагностических данных',
            'P1746': 'Ошибка интегрирования диагностических данных',
            'P1747': 'Ошибка дискретизации диагностических данных',
            'P1748': 'Ошибка квантования диагностических данных',
            'P1749': 'Ошибка оцифровки диагностических данных',
            'P1750': 'Ошибка аналоговой обработки диагностических данных',
            'P1751': 'Ошибка цифровой обработки диагностических данных',
            'P1752': 'Ошибка смешанной обработки диагностических данных',
            'P1753': 'Ошибка параллельной обработки диагностических данных',
            'P1754': 'Ошибка последовательной обработки диагностических данных',
            'P1755': 'Ошибка конвейерной обработки диагностических данных',
            'P1756': 'Ошибка векторной обработки диагностических данных',
            'P1757': 'Ошибка матричной обработки диагностических данных',
            'P1758': 'Ошибка тензорной обработки диагностических данных',
            'P1759': 'Ошибка скалярной обработки диагностических данных',
            'P1760': 'Ошибка полиномиальной обработки диагностических данных',
            'P1761': 'Ошибка экспоненциальной обработки диагностических данных',
            'P1762': 'Ошибка логарифмической обработки диагностических данных',
            'P1763': 'Ошибка тригонометрической обработки диагностических данных',
            'P1764': 'Ошибка гиперболической обработки диагностических данных',
            'P1765': 'Ошибка статистической обработки диагностических данных',
            'P1766': 'Ошибка вероятностной обработки диагностических данных',
            'P1767': 'Ошибка стохастической обработки диагностических данных',
            'P1768': 'Ошибка детерминированной обработки диагностических данных',
            'P1769': 'Ошибка хаотической обработки диагностических данных',
            'P1770': 'Ошибка фрактальной обработки диагностических данных',
            'P1771': 'Ошибка вейвлетной обработки диагностических данных',
            'P1772': 'Ошибка фурье-обработки диагностических данных',
            'P1773': 'Ошибка лаплас-обработки диагностических данных',
            'P1774': 'Ошибка z-обработки диагностических данных',
            'P1775': 'Ошибка гильберт-обработки диагностических данных',
            'P1776': 'Ошибка спектральной обработки диагностических данных',
            'P1777': 'Ошибка корреляционной обработки диагностических данных',
            'P1778': 'Ошибка ковариационной обработки диагностических данных',
            'P1779': 'Ошибка автокорреляционной обработки диагностических данных',
            'P1780': 'Ошибка кросскорреляционной обработки диагностических данных',
            'P1781': 'Ошибка сверточной обработки диагностических данных',
            'P1782': 'Ошибка пулинговой обработки диагностических данных',
            'P1783': 'Ошибка нормализационной обработки диагностических данных',
            'P1784': 'Ошибка стандартизационной обработки диагностических данных',
            'P1785': 'Ошибка регуляризационной обработки диагностических данных',
            'P1786': 'Ошибка оптимизационной обработки диагностических данных',
            'P1787': 'Ошибка градиентной обработки диагностических данных',
            'P1788': 'Ошибка эвристической обработки диагностических данных',
            'P1789': 'Ошибка метаэвристической обработки диагностических данных',
            'P1790': 'Ошибка генетической обработки диагностических данных',
            'P1791': 'Ошибка нейронной обработки диагностических данных',
            'P1792': 'Ошибка нечеткой обработки диагностических данных',
            'P1793': 'Ошибка экспертной обработки диагностических данных',
            'P1794': 'Ошибка байесовской обработки диагностических данных',
            'P1795': 'Ошибка марковской обработки диагностических данных',
            'P1796': 'Ошибка голоморфной обработки диагностических данных',
            'P1797': 'Ошибка мероморфной обработки диагностических данных',
            'P1798': 'Ошибка аналитической обработки диагностических данных',
            'P1799': 'Ошибка синтетической обработки диагностических данных',
            'U0001': 'Неисправность шины CAN',
            'U0002': 'Высокоскоростная шина CAN, обрыв связи',
            'U0003': 'Низкоскоростная шина CAN, обрыв связи',
            'U0100': 'Потеря связи с контроллером двигателя',
            'U0101': 'Потеря связи с контроллером трансмиссии',
            'U0102': 'Потеря связи с контроллером трансфер-бокса',
            'U0103': 'Потеря связи с контроллером раздаточной коробки',
            'U0104': 'Потеря связи с контроллером системы полного привода',
            'U0105': 'Потеря связи с контроллером системы блокировки дифференциала',
            'U0106': 'Потеря связи с контроллером системы помощи при спуске',
            'U0107': 'Потеря связи с контроллером системы помощи при подъеме',
            'U0108': 'Потеря связи с контроллером системы стабилизации',
            'U0109': 'Потеря связи с контроллером системы курсовой устойчивости',
            'U0110': 'Потеря связи с контроллером системы антипробуксовки',
            'U0111': 'Потеря связи с контроллером системы экстренного торможения',
            'U0112': 'Потеря связи с контроллером системы адаптивного круиз-контроля',
            'U0113': 'Потеря связи с контроллером системы предупреждения столкновения',
            'U0114': 'Потеря связи с контроллером системы автоматического торможения',
            'U0115': 'Потеря связи с контроллером системы помощи движению по полосе',
            'U0116': 'Потеря связи с контроллером системы распознавания дорожных знаков',
            'U0117': 'Потеря связи с контроллером системы ночного видения',
            'U0118': 'Потеря связи с контроллером системы контроля слепых зон',
            'U0119': 'Потеря связи с контроллером системы помощи при парковке',
            'U0120': 'Потеря связи с контроллером системы автоматической парковки',
            'U0121': 'Потеря связи с контроллером системы круиз-контроля',
            'U0122': 'Потеря связи с контроллером системы контроля давления в шинах',
            'U0123': 'Потеря связи с контроллером системы подвески',
            'U0124': 'Потеря связи с контроллером системы амортизации',
            'U0125': 'Потеря связи с контроллером системы стабилизации подвески',
            'U0126': 'Потеря связи с контроллером системы регулировки высоты',
            'U0127': 'Потеря связи с контроллером системы регулировки жесткости',
            'U0128': 'Потеря связи с контроллером системы регулировки демпфирования',
            'U0129': 'Потеря связи с контроллером системы пневмоподвески',
            'U0130': 'Потеря связи с контроллером системы гидроподвески',
            'U0131': 'Потеря связи с контроллером системы электроподвески',
            'U0132': 'Потеря связи с контроллером системы магнитной подвески',
            'U0133': 'Потеря связи с контроллером системы активной подвески',
            'U0134': 'Потеря связи с контроллером системы полуактивной подвески',
            'U0135': 'Потеря связи с контроллером системы пассивной подвески',
            'U0136': 'Потеря связи с контроллером системы многорычажной подвески',
            'U0137': 'Потеря связи с контроллером системы подвески Макферсон',
            'U0138': 'Потеря связи с контроллером системы подвески на двойных поперечных рычагах',
            'U0139': 'Потеря связи с контроллером системы торсионной подвески',
            'U0140': 'Потеря связи с контроллером системы рессорной подвески',
            'U0141': 'Потеря связи с контроллером системы пружинной подвески',
            'U0142': 'Потеря связи с контроллером системы балансирной подвески',
            'U0143': 'Потеря связи с контроллером системы независимой подвески',
            'U0144': 'Потеря связи с контроллером системы зависимой подвески',
            'U0145': 'Потеря связи с контроллером системы полузависимой подвески',
            'U0146': 'Потеря связи с контроллером системы подвески типа Де Дион',
            'U0147': 'Потеря связи с контроллером системы подвески с качающимися полуосями',
            'U0148': 'Потеря связи с контроллером системы подвески на продольных рычагах',
            'U0149': 'Потеря связи с контроллером системы подвески на косых рычагах',
            'U0150': 'Потеря связи с контроллером системы подвески на продольных и поперечных рычагах',
            'U0151': 'Потеря связи с контроллером системы подвески с гидроупругим элементом',
            'U0152': 'Потеря связи с контроллером системы подвески с пневмоупругим элементом',
            'U0153': 'Потеря связи с контроллером системы подвески с механическим упругим элементом',
            'U0154': 'Потеря связи с контроллером системы подвески с комбинированным упругим элементом',
            'U0155': 'Потеря связи с контроллером модуля подушек безопасности',
            'U0156': 'Потеря связи с контроллером модуля натяжителей ремней безопасности',
            'U0157': 'Потеря связи с контроллером модуля датчиков удара',
            'U0158': 'Потеря связи с контроллером модуля датчиков занятости сидений',
            'U0159': 'Потеря связи с контроллером модуля датчиков положения сидений',
            'U0160': 'Потеря связи с контроллером модуля датчиков веса',
            'U0161': 'Потеря связи с контроллером модуля датчиков наклона',
            'U0162': 'Потеря связи с контроллером модуля датчиков ускорения',
            'U0163': 'Потеря связи с контроллером модуля датчиков угловой скорости',
            'U0164': 'Потеря связи с контроллером модуля датчиков магнитного поля',
            'U0165': 'Потеря связи с контроллером модуля датчиков давления',
            'U0166': 'Потеря связи с контроллером модуля датчиков температуры',
            'U0167': 'Потеря связи с контроллером модуля датчиков влажности',
            'U0168': 'Потеря связи с контроллером модуля датчиков освещенности',
            'U0169': 'Потеря связи с контроллером модуля датчиков звука',
            'U0170': 'Потеря связи с контроллером модуля датчиков вибрации',
            'U0171': 'Потеря связи с контроллером модуля датчиков инфракрасного излучения',
            'U0172': 'Потеря связи с контроллером модуля датчиков ультрафиолетового излучения',
            'U0173': 'Потеря связи с контроллером модуля датчиков рентгеновского излучения',
            'U0174': 'Потеря связи с контроллером модуля датчиков гамма-излучения',
            'U0175': 'Потеря связи с контроллером модуля датчиков нейтронного излучения',
            'U0176': 'Потеря связи с контроллером модуля датчиков протонного излучения',
            'U0177': 'Потеря связи с контроллером модуля датчиков электронного излучения',
            'U0178': 'Потеря связи с контроллером модуля датчиков позитронного излучения',
            'U0179': 'Потеря связи с контроллером модуля датчиков мюонного излучения',
            'U0180': 'Потеря связи с контроллером модуля датчиков тау-излучения',
            'U0181': 'Потеря связи с контроллером модуля датчиков нейтринного излучения',
            'U0182': 'Потеря связи с контроллером модуля датчиков гравитационного излучения',
            'U0183': 'Потеря связи с контроллером модуля датчиков электромагнитного излучения',
            'U0184': 'Потеря связи с контроллером модуля датчиков акустического излучения',
            'U0185': 'Потеря связи с контроллером модуля датчиков теплового излучения',
            'U0186': 'Потеря связи с контроллером модуля датчиков химического излучения',
            'U0187': 'Потеря связи с контроллером модуля датчиков биологического излучения',
            'U0188': 'Потеря связи с контроллером модуля датчиков механического излучения',
            'U0189': 'Потеря связи с контроллером модуля датчиков оптического излучения',
            'U0190': 'Потеря связи с контроллером модуля датчиков ядерного излучения',
            'U0191': 'Потеря связи с контроллером модуля датчиков космического излучения',
            'U0192': 'Потеря связи с контроллером модуля датчиков атмосферного излучения',
            'U0193': 'Потеря связи с контроллером модуля датчиков земного излучения',
            'U0194': 'Потеря связи с контроллером модуля датчиков солнечного излучения',
            'U0195': 'Потеря связи с контроллером модуля датчиков лунного излучения',
            'U0196': 'Потеря связи с контроллером модуля датчиков звездного излучения',
            'U0197': 'Потеря связи с контроллером модуля датчиков галактического излучения',
            'U0198': 'Потеря связи с контроллером модуля датчиков межгалактического излучения',
            'U0199': 'Потеря связи с контроллером модуля датчиков реликтового излучения',
            'B0001': 'Неисправность драйвера водительской подушки безопасности',
            'B0002': 'Неисправность драйвера пассажирской подушки безопасности',
            'B0003': 'Неисправность драйвера боковой подушки безопасности водителя',
            'B0004': 'Неисправность драйвера боковой подушки безопасности пассажира',
            'B0005': 'Неисправность драйвера шторки безопасности водителя',
            'B0006': 'Неисправность драйвера шторки безопасности пассажира',
            'B0007': 'Неисправность драйвера коленной подушки безопасности водителя',
            'B0008': 'Неисправность драйвера коленной подушки безопасности пассажира',
            'B0009': 'Неисправность драйвера подушки безопасности ремня безопасности',
            'B0010': 'Неисправность драйвера натяжителя ремня безопасности',
            'B0011': 'Неисправность датчика удара спереди',
            'B0012': 'Неисправность датчика удара сзади',
            'B0013': 'Неисправность датчика удара слева',
            'B0014': 'Неисправность датчика удара справа',
            'B0015': 'Неисправность датчика занятости сиденья водителя',
            'B0016': 'Неисправность датчика занятости сиденья пассажира',
            'B0017': 'Неисправность датчика положения сиденья водителя',
            'B0018': 'Неисправность датчика положения сиденья пассажира',
            'B0019': 'Неисправность датчика веса сиденья водителя',
            'B0020': 'Неисправность датчика веса сиденья пассажира',
            'B0021': 'Неисправность датчика наклона автомобиля',
            'B0022': 'Неисправность датчика ускорения автомобиля',
            'B0023': 'Неисправность датчика угловой скорости автомобиля',
            'B0024': 'Неисправность датчика скорости автомобиля',
            'B0025': 'Неисправность датчика давления в шинах',
            'B0026': 'Неисправность датчика температуры в салоне',
            'B0027': 'Неисправность датчика влажности в салоне',
            'B0028': 'Неисправность датчика качества воздуха',
            'B0029': 'Неисправность датчика углекислого газа',
            'B0030': 'Неисправность датчика угарного газа',
            'B0031': 'Неисправность датчика кислорода',
            'B0032': 'Неисправность датчика азота',
            'B0033': 'Неисправность датчика водорода',
            'B0034': 'Неисправность датчика гелия',
            'B0035': 'Неисправность датчика аргона',
            'B0036': 'Неисправность датчика неона',
            'B0037': 'Неисправность датчика криптона',
            'B0038': 'Неисправность датчика ксенона',
            'B0039': 'Неисправность датчика радона',
            'B0040': 'Неисправность датчика метана',
            'B0041': 'Неисправность датчика пропана',
            'B0042': 'Неисправность датчика бутана',
            'B0043': 'Неисправность датчика этана',
            'B0044': 'Неисправность датчика этилена',
            'B0045': 'Неисправность датчика ацетилена',
            'B0046': 'Неисправность датчика бензола',
            'B0047': 'Неисправность датчика толуола',
            'B0048': 'Неисправность датчика ксилола',
            'B0049': 'Неисправность датчика нафталина',
            'B0050': 'Неисправность датчика антрацена',
            'B0051': 'Неисправность датчика фенантрена',
            'B0052': 'Неисправность датчика пирена',
            'B0053': 'Неисправность датчика бензопирена',
            'B0054': 'Неисправность датчика дибензопирена',
            'B0055': 'Неисправность датчика бензофлуорантена',
            'B0056': 'Неисправность датчика бензофлуорена',
            'B0057': 'Неисправность датчика бензотиофена',
            'B0058': 'Неисправность датчика бензоселенофена',
            'B0059': 'Неисправность датчика бензотеллурофена',
            'B0060': 'Неисправность датчика бензофосфола',
            'B0061': 'Неисправность датчика бензоарсола',
            'B0062': 'Неисправность датчика бензостибола',
            'B0063': 'Неисправность датчика бензобисмутола',
            'B0064': 'Неисправность датчика бензогермола',
            'B0065': 'Неисправность датчика бензостаннола',
            'B0066': 'Неисправность датчика бензоплюмбола',
            'B0067': 'Неисправность датчика бензополона',
            'B0068': 'Неисправность датчика бензофлеровия',
            'B0069': 'Неисправность датчика бензомосковия',
            'B0070': 'Неисправность датчика бензоливермория',
            'B0071': 'Неисправность датчика бензотеннессина',
            'B0072': 'Неисправность датчика бензооганессона',
            'B0073': 'Неисправность датчика бензонихония',
            'B0074': 'Неисправность датчика бензофлеровиума',
            'B0075': 'Неисправность датчика бензомосковиума',
            'B0076': 'Неисправность датчика бензоливермориума',
            'B0077': 'Неисправность датчика бензотеннессинума',
            'B0078': 'Неисправность датчика бензооганессона',
            'B0079': 'Неисправность датчика бензонихония',
            'B0080': 'Неисправность датчика бензофлеровиума',
            'B0081': 'Неисправность датчика бензомосковиума',
            'B0082': 'Неисправность датчика бензоливермориума',
            'B0083': 'Неисправность датчика бензотеннессинума',
            'B0084': 'Неисправность датчика бензооганессона',
            'B0085': 'Неисправность датчика бензонихония',
            'B0086': 'Неисправность датчика бензофлеровиума',
            'B0087': 'Неисправность датчика бензомосковиума',
            'B0088': 'Неисправность датчика бензоливермориума',
            'B0089': 'Неисправность датчика бензотеннессинума',
            'B0090': 'Неисправность датчика бензооганессона',
            'B0091': 'Неисправность датчика бензонихония',
            'B0092': 'Неисправность датчика бензофлеровиума',
            'B0093': 'Неисправность датчика бензомосковиума',
            'B0094': 'Неисправность датчика бензоливермориума',
            'B0095': 'Неисправность датчика бензотеннессинума',
            'B0096': 'Неисправность датчика бензооганессона',
            'B0097': 'Неисправность датчика бензонихония',
            'B0098': 'Неисправность датчика бензофлеровиума',
            'B0099': 'Неисправность датчика бензомосковиума',
            'C0001': 'Неисправность датчика скорости переднего левого колеса',
            'C0002': 'Неисправность датчика скорости переднего правого колеса',
            'C0003': 'Неисправность датчика скорости заднего левого колеса',
            'C0004': 'Неисправность датчика скорости заднего правого колеса',
            'C0005': 'Неисправность клапана ABS переднего левого колеса',
            'C0006': 'Неисправность клапана ABS переднего правого колеса',
            'C0007': 'Неисправность клапана ABS заднего левого колеса',
            'C0008': 'Неисправность клапана ABS заднего правого колеса',
            'C0009': 'Неисправность насоса ABS',
            'C0010': 'Неисправность реле насоса ABS',
            'C0011': 'Неисправность реле клапанов ABS',
            'C0012': 'Неисправность модуля управления ABS',
            'C0013': 'Неисправность датчика давления тормозной жидкости',
            'C0014': 'Неисправность датчика положения педали тормоза',
            'C0015': 'Неисправность датчика усилия на педали тормоза',
            'C0016': 'Неисправность датчика температуры тормозных колодок',
            'C0017': 'Неисправность датчика износа тормозных колодок',
            'C0018': 'Неисправность датчика уровня тормозной жидкости',
            'C0019': 'Неисправность датчика вакуума в усилителе тормозов',
            'C0020': 'Неисправность датчика давления в тормозной системе',
            'C0021': 'Неисправность датчика ускорения автомобиля (для ABS)',
            'C0022': 'Неисправность датчика угловой скорости (для ABS)',
            'C0023': 'Неисправность датчика поперечного ускорения',
            'C0024': 'Неисправность датчика продольного ускорения',
            'C0025': 'Неисправность датчика вертикального ускорения',
            'C0026': 'Неисправность датчика крена',
            'C0027': 'Неисправность датчика тангажа',
            'C0028': 'Неисправность датчика рыскания',
            'C0029': 'Неисправность датчика курса',
            'C0030': 'Неисправность датчика широты',
            'C0031': 'Неисправность датчика долготы',
            'C0032': 'Неисправность датчика высоты',
            'C0033': 'Неисправность датчика скорости относительно земли',
            'C0034': 'Неисправность датчика скорости относительно воздуха',
            'C0035': 'Неисправность датчика скорости относительно воды',
            'C0036': 'Неисправность датчика скорости относительно льда',
            'C0037': 'Неисправность датчика скорости относительно снега',
            'C0038': 'Неисправность датчика скорости относительно грязи',
            'C0039': 'Неисправность датчика скорости относительно песка',
            'C0040': 'Неисправность датчика скорости относительно гравия',
            'C0041': 'Неисправность датчика скорости относительно асфальта',
            'C0042': 'Неисправность датчика скорости относительно бетона',
            'C0043': 'Неисправность датчика скорости относительно грунта',
            'C0044': 'Неисправность датчика скорости относительно травы',
            'C0045': 'Неисправность датчика скорости относительно листьев',
            'C0046': 'Неисправность датчика скорости относительно веток',
            'C0047': 'Неисправность датчика скорости относительно камней',
            'C0048': 'Неисправность датчика скорости относительно корней',
            'C0049': 'Неисправность датчика скорости относительно пней',
            'C0050': 'Неисправность датчика скорости относительно бревен',
            'C0051': 'Неисправность датчика скорости относительно досок',
            'C0052': 'Неисправность датчика скорости относительно металла',
            'C0053': 'Неисправность датчика скорости относительно пластика',
            'C0054': 'Неисправность датчика скорости относительно стекла',
            'C0055': 'Неисправность датчика скорости относительно резины',
            'C0056': 'Неисправность датчика скорости относительно кожи',
            'C0057': 'Неисправность датчика скорости относительно ткани',
            'C0058': 'Неисправность датчика скорости относительно бумаги',
            'C0059': 'Неисправность датчика скорости относительно картона',
            'C0060': 'Неисправность датчика скорости относительно фанеры',
            'C0061': 'Неисправность датчика скорости относительно ДСП',
            'C0062': 'Неисправность датчика скорости относительно ДВП',
            'C0063': 'Неисправность датчика скорости относительно МДФ',
            'C0064': 'Неисправность датчика скорости относительно OSB',
            'C0065': 'Неисправность датчика скорости относительно фанеры',
            'C0066': 'Неисправность датчика скорости относительно шпона',
            'C0067': 'Неисправность датчика скорости относительно массива',
            'C0068': 'Неисправность датчика скорости относительно паркета',
            'C0069': 'Неисправность датчика скорости относительно ламината',
            'C0070': 'Неисправность датчика скорости относительно линолеума',
            'C0071': 'Неисправность датчика скорости относительно ковролина',
            'C0072': 'Неисправность датчика скорости относительно плитки',
            'C0073': 'Неисправность датчика скорости относительно кафеля',
            'C0074': 'Неисправность датчика скорости относительно мрамора',
            'C0075': 'Неисправность датчика скорости относительно гранита',
            'C0076': 'Неисправность датчика скорости относительно известняка',
            'C0077': 'Неисправность датчика скорости относительно песчаника',
            'C0078': 'Неисправность датчика скорости относительно сланца',
            'C0079': 'Неисправность датчика скорости относительно базальта',
            'C0080': 'Неисправность датчика скорости относительно андезита',
            'C0081': 'Неисправность датчика скорости относительно диабаза',
            'C0082': 'Неисправность датчика скорости относительно габбро',
            'C0083': 'Неисправность датчика скорости относительно перидотита',
            'C0084': 'Неисправность датчика скорости относительно дунита',
            'C0085': 'Неисправность датчика скорости относительно гарцбургита',
            'C0086': 'Неисправность датчика скорости относительно лерцолита',
            'C0087': 'Неисправность датчика скорости относительно верлита',
            'C0088': 'Неисправность датчика скорости относительно пироксенита',
            'C0089': 'Неисправность датчика скорости относительно анортозита',
            'C0090': 'Неисправность датчика скорости относительно троктолита',
            'C0091': 'Неисправность датчика скорости относительно норита',
            'C0092': 'Неисправность датчика скорости относительно гранулита',
            'C0093': 'Неисправность датчика скорости относительно эклогита',
            'C0094': 'Неисправность датчика скорости относительно амфиболита',
            'C0095': 'Неисправность датчика скорости относительно гнейса',
            'C0096': 'Неисправность датчика скорости относительно сланца',
            'C0097': 'Неисправность датчика скорости относительно филлита',
            'C0098': 'Неисправность датчика скорости относительно серпентинита',
            'C0099': 'Неисправность датчика скорости относительно талька',
        }
    }
    
    return dtc_database.get(language, {}).get(dtc_code, "Неизвестная ошибка")


def validate_vin(vin: str) -> ValidationResult:
    """
    Проверка валидности VIN номера
    
    Args:
        vin: VIN номер для проверки
        
    Returns:
        Результат валидации
    """
    result = ValidationResult()
    
    if not vin:
        result.add_error("VIN номер не может быть пустым")
        return result
    
    # Очищаем от пробелов и переводим в верхний регистр
    vin = vin.strip().upper()
    
    # Проверяем длину (стандартный VIN имеет 17 символов)
    if len(vin) != 17:
        result.add_error(f"VIN номер должен содержать 17 символов, получено {len(vin)}")
    
    # Проверяем допустимые символы
    # Не допускаются буквы I, O, Q
    invalid_chars = re.findall(r'[IOQ]', vin)
    if invalid_chars:
        result.add_error(f"VIN содержит недопустимые символы: {', '.join(set(invalid_chars))}")
    
    # Проверяем контрольную сумму для североамериканских VIN (позиция 9)
    if result.is_valid:
        # Проверяем только если VIN североамериканский
        if vin[0] in ['1', '2', '3', '4', '5']:  # Северная Америка
            try:
                checksum = calculate_vin_checksum(vin)
                if checksum != vin[8] and vin[8] != '0':
                    result.add_warning("Контрольная сумма VIN не совпадает")
            except:
                result.add_warning("Не удалось проверить контрольную сумму VIN")
    
    return result


def calculate_vin_checksum(vin: str) -> str:
    """
    Вычисление контрольной суммы VIN номера
    
    Args:
        vin: VIN номер
        
    Returns:
        Контрольная сумма
    """
    # Веса позиций
    weights = [8, 7, 6, 5, 4, 3, 2, 10, 0, 9, 8, 7, 6, 5, 4, 3, 2]
    
    # Эквиваленты символов
    char_values = {
        'A': 1, 'B': 2, 'C': 3, 'D': 4, 'E': 5, 'F': 6, 'G': 7, 'H': 8,
        'J': 1, 'K': 2, 'L': 3, 'M': 4, 'N': 5, 'P': 7, 'R': 9, 'S': 2,
        'T': 3, 'U': 4, 'V': 5, 'W': 6, 'X': 7, 'Y': 8, 'Z': 9,
        '0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9
    }
    
    # Вычисляем сумму произведений
    total = 0
    for i, char in enumerate(vin):
        if char in char_values:
            total += char_values[char] * weights[i]
        else:
            raise ValueError(f"Неизвестный символ в VIN: {char}")
    
    # Вычисляем контрольную цифру
    remainder = total % 11
    
    if remainder == 10:
        return 'X'
    else:
        return str(remainder)


def create_vehicle_profile(vehicle_info: VehicleInfo) -> Dict[str, Any]:
    """
    Создание профиля автомобиля
    
    Args:
        vehicle_info: Информация об автомобиле
        
    Returns:
        Профиль автомобиля
    """
    profile = {
        'vehicle': vehicle_info.to_dict(),
        'created_at': datetime.datetime.now().isoformat(),
        'last_modified': datetime.datetime.now().isoformat(),
        'diagnostic_history': [],
        'adaptation_settings': {},
        'custom_parameters': {},
    }
    
    return profile


def save_vehicle_profile(profile: Dict[str, Any], filepath: str) -> bool:
    """
    Сохранение профиля автомобиля в файл
    
    Args:
        profile: Профиль автомобиля
        filepath: Путь к файлу
        
    Returns:
        Успешность сохранения
    """
    try:
        profile['last_modified'] = datetime.datetime.now().isoformat()
        
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(profile, f, ensure_ascii=False, indent=2)
        
        return True
        
    except Exception as e:
        print(f"Ошибка сохранения профиля: {e}")
        return False


def load_vehicle_profile(filepath: str) -> Optional[Dict[str, Any]]:
    """
    Загрузка профиля автомобиля из файла
    
    Args:
        filepath: Путь к файлу
        
    Returns:
        Профиль автомобиля или None в случае ошибки
    """
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            profile = json.load(f)
        
        return profile
        
    except Exception as e:
        print(f"Ошибка загрузки профиля: {e}")
        return None


def calculate_fuel_consumption(distance: float, fuel_used: float, 
                               unit_system: str = "metric") -> Dict[str, float]:
    """
    Расчет расхода топлива
    
    Args:
        distance: Пройденное расстояние
        fuel_used: Использованное топливо
        unit_system: Система единиц (metric/imperial)
        
    Returns:
        Словарь с различными единицами расхода
    """
    if distance <= 0 or fuel_used <= 0:
        return {
            'l_per_100km': 0.0,
            'km_per_l': 0.0,
            'mpg_us': 0.0,
            'mpg_uk': 0.0,
        }
    
    if unit_system == "metric":
        # Литры на 100 км
        l_per_100km = (fuel_used / distance) * 100
        
        # Км на литр
        km_per_l = distance / fuel_used
        
        # MPG (US)
        mpg_us = 235.215 / l_per_100km
        
        # MPG (UK)
        mpg_uk = 282.481 / l_per_100km
        
    else:  # imperial
        # Галлоны на милю
        gallons_per_mile = fuel_used / distance
        
        # MPG (US)
        mpg_us = 1 / gallons_per_mile if gallons_per_mile > 0 else 0
        
        # MPG (UK)
        mpg_uk = mpg_us * 1.20095
        
        # Литры на 100 км
        l_per_100km = 235.215 / mpg_us if mpg_us > 0 else 0
        
        # Км на литр
        km_per_l = 100 / l_per_100km if l_per_100km > 0 else 0
    
    return {
        'l_per_100km': round(l_per_100km, 2),
        'km_per_l': round(km_per_l, 2),
        'mpg_us': round(mpg_us, 2),
        'mpg_uk': round(mpg_uk, 2),
    }


def analyze_sensor_data(sensor_data: List[float], sampling_rate: float = 1.0) -> Dict[str, Any]:
    """
    Анализ данных с датчиков
    
    Args:
        sensor_data: Список значений датчика
        sampling_rate: Частота дискретизации (Гц)
        
    Returns:
        Статистика данных
    """
    if not sensor_data:
        return {
            'count': 0,
            'mean': 0.0,
            'std': 0.0,
            'min': 0.0,
            'max': 0.0,
            'median': 0.0,
            'variance': 0.0,
            'range': 0.0,
        }
    
    data_array = np.array(sensor_data)
    
    # Основная статистика
    stats = {
        'count': len(data_array),
        'mean': float(np.mean(data_array)),
        'std': float(np.std(data_array)),
        'min': float(np.min(data_array)),
        'max': float(np.max(data_array)),
        'median': float(np.median(data_array)),
        'variance': float(np.var(data_array)),
        'range': float(np.max(data_array) - np.min(data_array)),
    }
    
    # Дополнительные метрики
    stats['cv'] = stats['std'] / stats['mean'] if stats['mean'] != 0 else 0  # Коэффициент вариации
    
    # Анализ тренда
    if len(data_array) > 1:
        x = np.arange(len(data_array))
        slope, intercept = np.polyfit(x, data_array, 1)
        stats['trend_slope'] = float(slope)
        stats['trend_intercept'] = float(intercept)
        
        # Прогноз следующего значения
        stats['next_value_prediction'] = float(slope * len(data_array) + intercept)
    else:
        stats['trend_slope'] = 0.0
        stats['trend_intercept'] = 0.0
        stats['next_value_prediction'] = 0.0
    
    return stats


def detect_anomalies(data: List[float], threshold: float = 3.0) -> List[Dict[str, Any]]:
    """
    Обнаружение аномалий в данных
    
    Args:
        data: Список значений
        threshold: Порог для определения аномалий (в стандартных отклонениях)
        
    Returns:
        Список обнаруженных аномалий
    """
    if len(data) < 3:
        return []
    
    data_array = np.array(data)
    mean = np.mean(data_array)
    std = np.std(data_array)
    
    anomalies = []
    
    for i, value in enumerate(data):
        z_score = abs((value - mean) / std) if std != 0 else 0
        
        if z_score > threshold:
            anomalies.append({
                'index': i,
                'value': float(value),
                'z_score': float(z_score),
                'deviation': float(value - mean),
                'timestamp': datetime.datetime.now() + datetime.timedelta(seconds=i)
            })
    
    return anomalies


def interpolate_missing_values(data: List[Optional[float]], method: str = 'linear') -> List[float]:
    """
    Интерполяция пропущенных значений
    
    Args:
        data: Список значений с пропусками (None)
        method: Метод интерполяции (linear, quadratic, cubic)
        
    Returns:
        Список с интерполированными значениями
    """
    if not data:
        return []
    
    # Находим индексы пропущенных значений
    valid_indices = [i for i, v in enumerate(data) if v is not None]
    valid_values = [data[i] for i in valid_indices]
    
    if not valid_values:
        return [0.0] * len(data)
    
    if len(valid_values) == 1:
        # Если только одно значение, заполняем им все
        return [valid_values[0]] * len(data)
    
    # Интерполяция
    if method == 'linear':
        interpolated = np.interp(range(len(data)), valid_indices, valid_values)
    else:
        # Для нелинейных методов используем полиномиальную интерполяцию
        poly = np.polyfit(valid_indices, valid_values, 
                          min(3, len(valid_values) - 1))  # До кубического полинома
        interpolated = np.polyval(poly, range(len(data)))
    
    return [float(v) for v in interpolated]


def smooth_data(data: List[float], window_size: int = 5, 
                method: str = 'moving_average') -> List[float]:
    """
    Сглаживание данных
    
    Args:
        data: Список значений
        window_size: Размер окна сглаживания
        method: Метод сглаживания (moving_average, median, savgol)
        
    Returns:
        Сглаженные данные
    """
    if len(data) < window_size:
        return data.copy()
    
    data_array = np.array(data)
    
    if method == 'moving_average':
        smoothed = np.convolve(data_array, np.ones(window_size)/window_size, mode='same')
    
    elif method == 'median':
        smoothed = np.zeros_like(data_array)
        half_window = window_size // 2
        
        for i in range(len(data_array)):
            start = max(0, i - half_window)
            end = min(len(data_array), i + half_window + 1)
            smoothed[i] = np.median(data_array[start:end])
    
    elif method == 'savgol':
        from scipy.signal import savgol_filter
        smoothed = savgol_filter(data_array, window_size, 2)  # Полином 2-го порядка
    
    else:
        return data.copy()
    
    return [float(v) for v in smoothed]


def create_timestamp() -> str:
    """
    Создание временной метки в формате ISO с миллисекундами
    
    Returns:
        Строка с временной меткой
    """
    return datetime.datetime.now().isoformat(timespec='milliseconds')


def time_function(func: Callable) -> Callable:
    """
    Декоратор для измерения времени выполнения функции
    
    Args:
        func: Функция для измерения
        
    Returns:
        Обернутая функция
    """
    def wrapper(*args, **kwargs):
        start_time = time.perf_counter()
        result = func(*args, **kwargs)
        end_time = time.perf_counter()
        
        elapsed = end_time - start_time
        print(f"Функция {func.__name__} выполнена за {elapsed:.4f} секунд")
        
        return result
    
    return wrapper


def retry_on_exception(max_retries: int = 3, delay: float = 1.0, 
                       exceptions: tuple = (Exception,)) -> Callable:
    """
    Декоратор для повторного выполнения функции при возникновении исключений
    
    Args:
        max_retries: Максимальное количество попыток
        delay: Задержка между попытками (секунды)
        exceptions: Кортеж исключений для перехвата
        
    Returns:
        Обернутая функция
    """
    def decorator(func: Callable) -> Callable:
        def wrapper(*args, **kwargs):
            for attempt in range(max_retries):
                try:
                    return func(*args, **kwargs)
                except exceptions as e:
                    if attempt == max_retries - 1:
                        raise e
                    print(f"Попытка {attempt + 1} не удалась: {e}. Повтор через {delay} сек...")
                    time.sleep(delay)
            return None
        return wrapper
    return decorator


def format_duration(seconds: float) -> str:
    """
    Форматирование длительности в читаемый вид
    
    Args:
        seconds: Количество секунд
        
    Returns:
        Отформатированная строка
    """
    if seconds < 0:
        return "0 с"
    
    if seconds < 60:
        return f"{seconds:.1f} с"
    
    minutes = seconds / 60
    if minutes < 60:
        return f"{minutes:.1f} мин"
    
    hours = minutes / 60
    if hours < 24:
        return f"{hours:.1f} ч"
    
    days = hours / 24
    return f"{days:.1f} д"


def get_system_info() -> Dict[str, Any]:
    """
    Получение информации о системе
    
    Returns:
        Словарь с информацией о системе
    """
    import platform
    import psutil
    
    info = {
        'platform': platform.system(),
        'platform_release': platform.release(),
        'platform_version': platform.version(),
        'architecture': platform.machine(),
        'processor': platform.processor(),
        'python_version': platform.python_version(),
        'python_implementation': platform.python_implementation(),
    }
    
    # Информация о памяти
    try:
        memory = psutil.virtual_memory()
        info['memory_total_gb'] = round(memory.total / (1024**3), 2)
        info['memory_available_gb'] = round(memory.available / (1024**3), 2)
        info['memory_used_percent'] = memory.percent
    except:
        pass
    
    # Информация о диске
    try:
        disk = psutil.disk_usage('/')
        info['disk_total_gb'] = round(disk.total / (1024**3), 2)
        info['disk_used_gb'] = round(disk.used / (1024**3), 2)
        info['disk_free_gb'] = round(disk.free / (1024**3), 2)
        info['disk_used_percent'] = disk.percent
    except:
        pass
    
    return info


def create_backup(filepath: str, backup_dir: str = "backups") -> Optional[str]:
    """
    Создание резервной копии файла
    
    Args:
        filepath: Путь к исходному файлу
        backup_dir: Директория для бэкапов
        
    Returns:
        Путь к созданной резервной копии или None в случае ошибки
    """
    try:
        if not os.path.exists(filepath):
            return None
        
        # Создаем директорию для бэкапов если ее нет
        os.makedirs(backup_dir, exist_ok=True)
        
        # Генерируем имя файла бэкапа
        filename = os.path.basename(filepath)
        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_filename = f"{os.path.splitext(filename)[0]}_{timestamp}{os.path.splitext(filename)[1]}"
        backup_path = os.path.join(backup_dir, backup_filename)
        
        # Копируем файл
        import shutil
        shutil.copy2(filepath, backup_path)
        
        # Создаем файл с метаданными
        metadata = {
            'original_path': filepath,
            'backup_created': datetime.datetime.now().isoformat(),
            'file_size': os.path.getsize(filepath),
            'file_hash': calculate_file_hash(filepath),
        }
        
        metadata_path = backup_path + '.meta'
        with open(metadata_path, 'w', encoding='utf-8') as f:
            json.dump(metadata, f, indent=2)
        
        return backup_path
        
    except Exception as e:
        print(f"Ошибка создания бэкапа: {e}")
        return None


def calculate_file_hash(filepath: str, algorithm: str = 'sha256') -> str:
    """
    Вычисление хэша файла
    
    Args:
        filepath: Путь к файлу
        algorithm: Алгоритм хэширования
        
    Returns:
        Хэш файла в шестнадцатеричном формате
    """
    hash_func = hashlib.new(algorithm)
    
    try:
        with open(filepath, 'rb') as f:
            # Читаем файл блоками для экономии памяти
            for chunk in iter(lambda: f.read(4096), b''):
                hash_func.update(chunk)
        
        return hash_func.hexdigest()
        
    except Exception as e:
        print(f"Ошибка вычисления хэша файла: {e}")
        return ''


def find_latest_backup(backup_dir: str, pattern: str = "*") -> Optional[str]:
    """
    Поиск последней резервной копии
    
    Args:
        backup_dir: Директория с бэкапами
        pattern: Шаблон поиска
        
    Returns:
        Путь к последнему бэкапу или None
    """
    try:
        if not os.path.exists(backup_dir):
            return None
        
        # Получаем список файлов, соответствующих шаблону
        import glob
        files = glob.glob(os.path.join(backup_dir, pattern))
        
        if not files:
            return None
        
        # Сортируем по времени изменения
        files.sort(key=os.path.getmtime, reverse=True)
        
        return files[0]
        
    except Exception as e:
        print(f"Ошибка поиска бэкапа: {e}")
        return None


def restore_from_backup(backup_path: str, target_path: str) -> bool:
    """
    Восстановление файла из резервной копии
    
    Args:
        backup_path: Путь к резервной копии
        target_path: Путь для восстановления
        
    Returns:
        Успешность восстановления
    """
    try:
        if not os.path.exists(backup_path):
            return False
        
        # Проверяем метаданные если есть
        metadata_path = backup_path + '.meta'
        if os.path.exists(metadata_path):
            with open(metadata_path, 'r', encoding='utf-8') as f:
                metadata = json.load(f)
            
            # Проверяем хэш файла
            current_hash = calculate_file_hash(backup_path)
            if current_hash != metadata.get('file_hash'):
                print("Хэш файла не совпадает с метаданными")
                return False
        
        # Восстанавливаем файл
        import shutil
        shutil.copy2(backup_path, target_path)
        
        return True
        
    except Exception as e:
        print(f"Ошибка восстановления из бэкапа: {e}")
        return False


def compress_data(data: Dict[str, Any], compression_level: int = 6) -> bytes:
    """
    Сжатие данных
    
    Args:
        data: Данные для сжатия
        compression_level: Уровень сжатия (0-9)
        
    Returns:
        Сжатые данные
    """
    import zlib
    import json
    
    json_data = json.dumps(data).encode('utf-8')
    compressed = zlib.compress(json_data, level=compression_level)
    
    return compressed


def decompress_data(compressed_data: bytes) -> Optional[Dict[str, Any]]:
    """
    Распаковка данных
    
    Args:
        compressed_data: Сжатые данные
        
    Returns:
        Распакованные данные или None в случае ошибки
    """
    import zlib
    import json
    
    try:
        decompressed = zlib.decompress(compressed_data)
        data = json.loads(decompressed.decode('utf-8'))
        return data
    except:
        return None


def generate_report_filename(vehicle_info: VehicleInfo, report_type: str = "diagnostic") -> str:
    """
    Генерация имени файла отчета
    
    Args:
        vehicle_info: Информация об автомобиле
        report_type: Тип отчета
        
    Returns:
        Имя файла
    """
    timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
    
    # Безопасное имя для файла
    safe_model = re.sub(r'[^\w\s-]', '', vehicle_info.model).strip().replace(' ', '_')
    safe_vin = vehicle_info.vin[:8] if vehicle_info.vin else "UNKNOWN"
    
    filename = f"{report_type}_{safe_model}_{safe_vin}_{timestamp}.pdf"
    
    return filename


def safe_filename(filename: str, max_length: int = 255) -> str:
    """
    Создание безопасного имени файла
    
    Args:
        filename: Исходное имя файла
        max_length: Максимальная длина
        
    Returns:
        Безопасное имя файла
    """
    # Удаляем небезопасные символы
    safe_name = re.sub(r'[<>:"/\\|?*]', '_', filename)
    
    # Заменяем несколько подчеркиваний на одно
    safe_name = re.sub(r'_+', '_', safe_name)
    
    # Убираем начальные и конечные точки и пробелы
    safe_name = safe_name.strip('. ')
    
    # Ограничиваем длину
    if len(safe_name) > max_length:
        name, ext = os.path.splitext(safe_name)
        safe_name = name[:max_length - len(ext)] + ext
    
    return safe_name


def get_file_size_string(size_bytes: int) -> str:
    """
    Форматирование размера файла в читаемый вид
    
    Args:
        size_bytes: Размер в байтах
        
    Returns:
        Отформатированная строка
    """
    if size_bytes < 1024:
        return f"{size_bytes} Б"
    
    size_kb = size_bytes / 1024
    if size_kb < 1024:
        return f"{size_kb:.1f} КБ"
    
    size_mb = size_kb / 1024
    if size_mb < 1024:
        return f"{size_mb:.1f} МБ"
    
    size_gb = size_mb / 1024
    return f"{size_gb:.1f} ГБ"


def list_serial_ports() -> List[Dict[str, str]]:
    """
    Получение списка доступных COM портов
    
    Returns:
        Список словарей с информацией о портах
    """
    import serial.tools.list_ports
    
    ports = []
    
    try:
        available_ports = serial.tools.list_ports.comports()
        
        for port in available_ports:
            ports.append({
                'device': port.device,
                'name': port.name,
                'description': port.description,
                'manufacturer': port.manufacturer,
                'hwid': port.hwid,
                'vid': port.vid,
                'pid': port.pid,
                'serial_number': port.serial_number,
                'location': port.location,
            })
            
    except Exception as e:
        print(f"Ошибка получения списка портов: {e}")
    
    return ports


def list_bluetooth_devices() -> List[Dict[str, str]]:
    """
    Получение списка доступных Bluetooth устройств
    
    Returns:
        Список словарей с информацией об устройствах
    """
    devices = []
    
    try:
        import bluetooth
        
        nearby_devices = bluetooth.discover_devices(lookup_names=True, duration=8)
        
        for addr, name in nearby_devices:
            devices.append({
                'address': addr,
                'name': name,
                'services': bluetooth.find_service(address=addr)
            })
            
    except Exception as e:
        print(f"Ошибка поиска Bluetooth устройств: {e}")
    
    return devices


def calculate_engine_efficiency(engine_params: Dict[str, float]) -> Dict[str, float]:
    """
    Расчет эффективности двигателя
    
    Args:
        engine_params: Параметры двигателя
        
    Returns:
        Показатели эффективности
    """
    # Базовая эффективность
    efficiency = {
        'thermal_efficiency': 0.0,
        'mechanical_efficiency': 0.0,
        'volumetric_efficiency': 0.0,
        'overall_efficiency': 0.0,
    }
    
    try:
        # Примерные расчеты (нужно адаптировать под реальные формулы)
        rpm = engine_params.get('rpm', 0)
        load = engine_params.get('engine_load', 0)
        maf = engine_params.get('maf', 0)
        throttle = engine_params.get('throttle_position', 0)
        fuel_trim = engine_params.get('fuel_trim', 0)
        
        # Термический КПД (упрощенно)
        if rpm > 0 and load > 0:
            efficiency['thermal_efficiency'] = min(0.35 * (load / 100) * (1 - abs(fuel_trim) / 100), 0.4)
        
        # Механический КПД
        if rpm > 0:
            efficiency['mechanical_efficiency'] = 0.85 - (rpm / 6000) * 0.1
        
        # Объемный КПД
        if maf > 0 and throttle > 0:
            efficiency['volumetric_efficiency'] = min((maf * 100) / (throttle * 2), 1.0)
        
        # Общий КПД
        efficiency['overall_efficiency'] = (
            efficiency['thermal_efficiency'] * 
            efficiency['mechanical_efficiency'] * 
            efficiency['volumetric_efficiency']
        ) * 100
        
    except Exception as e:
        print(f"Ошибка расчета эффективности: {e}")
    
    return efficiency


def predict_fault_probability(sensor_data: Dict[str, float], 
                              model_type: str = "heuristic") -> Dict[str, float]:
    """
    Предсказание вероятности неисправностей
    
    Args:
        sensor_data: Данные с датчиков
        model_type: Тип модели для предсказания
        
    Returns:
        Вероятности неисправностей
    """
    probabilities = {}
    
    try:
        # Эвристическая модель (можно заменить на ML модель)
        if model_type == "heuristic":
            # Проверка температуры
            coolant_temp = sensor_data.get('coolant_temp', 90)
            if coolant_temp > 110:
                probabilities['overheating'] = 0.8
            elif coolant_temp > 100:
                probabilities['overheating'] = 0.3
            else:
                probabilities['overheating'] = 0.05
            
            # Проверка напряжения
            voltage = sensor_data.get('voltage', 13.5)
            if voltage < 11.5:
                probabilities['low_voltage'] = 0.9
            elif voltage < 12.0:
                probabilities['low_voltage'] = 0.5
            else:
                probabilities['low_voltage'] = 0.1
            
            # Проверка топливной системы
            fuel_trim = abs(sensor_data.get('fuel_trim', 0))
            if fuel_trim > 20:
                probabilities['fuel_system'] = 0.7
            elif fuel_trim > 10:
                probabilities['fuel_system'] = 0.3
            else:
                probabilities['fuel_system'] = 0.1
            
            # Проверка системы зажигания
            misfire_count = sensor_data.get('misfire_count', 0)
            if misfire_count > 50:
                probabilities['ignition'] = 0.8
            elif misfire_count > 10:
                probabilities['ignition'] = 0.4
            else:
                probabilities['ignition'] = 0.05
        
        # Нормализуем вероятности
        for key in probabilities:
            probabilities[key] = min(max(probabilities[key], 0), 1)
            
    except Exception as e:
        print(f"Ошибка предсказания неисправностей: {e}")
    
    return probabilities


def create_data_export(data: Dict[str, Any], export_format: str = "json") -> bytes:
    """
    Создание экспорта данных в различных форматах
    
    Args:
        data: Данные для экспорта
        export_format: Формат экспорта (json, csv, xml)
        
    Returns:
        Данные в выбранном формате
    """
    try:
        if export_format == "json":
            return json.dumps(data, ensure_ascii=False, indent=2).encode('utf-8')
        
        elif export_format == "csv":
            import io
            import csv
            
            # Преобразуем данные в плоскую структуру для CSV
            flat_data = flatten_dict(data)
            
            output = io.StringIO()
            writer = csv.DictWriter(output, fieldnames=flat_data.keys())
            writer.writeheader()
            writer.writerow(flat_data)
            
            return output.getvalue().encode('utf-8')
        
        elif export_format == "xml":
            root = ET.Element("diagnostic_data")
            
            def dict_to_xml(parent, data_dict):
                for key, value in data_dict.items():
                    if isinstance(value, dict):
                        child = ET.SubElement(parent, key)
                        dict_to_xml(child, value)
                    elif isinstance(value, list):
                        child = ET.SubElement(parent, key)
                        for item in value:
                            if isinstance(item, dict):
                                item_elem = ET.SubElement(child, "item")
                                dict_to_xml(item_elem, item)
                            else:
                                item_elem = ET.SubElement(child, "item")
                                item_elem.text = str(item)
                    else:
                        child = ET.SubElement(parent, key)
                        child.text = str(value)
            
            dict_to_xml(root, data)
            
            xml_str = ET.tostring(root, encoding='utf-8', method='xml')
            return xml_str
        
        else:
            raise ValueError(f"Неподдерживаемый формат экспорта: {export_format}")
            
    except Exception as e:
        print(f"Ошибка создания экспорта: {e}")
        return b''


def flatten_dict(data: Dict[str, Any], parent_key: str = '', sep: str = '_') -> Dict[str, Any]:
    """
    Преобразование вложенного словаря в плоский
    
    Args:
        data: Вложенный словарь
        parent_key: Ключ родительского элемента
        sep: Разделитель ключей
        
    Returns:
        Плоский словарь
    """
    items = []
    
    for key, value in data.items():
        new_key = f"{parent_key}{sep}{key}" if parent_key else key
        
        if isinstance(value, dict):
            items.extend(flatten_dict(value, new_key, sep=sep).items())
        elif isinstance(value, list):
            # Для списков сохраняем как строку JSON
            items.append((new_key, json.dumps(value, ensure_ascii=False)))
        else:
            items.append((new_key, value))
    
    return dict(items)


def deep_update(target: Dict, source: Dict) -> Dict:
    """
    Рекурсивное обновление словаря
    
    Args:
        target: Целевой словарь
        source: Источник обновления
        
    Returns:
        Обновленный словарь
    """
    for key, value in source.items():
        if key in target and isinstance(target[key], dict) and isinstance(value, dict):
            deep_update(target[key], value)
        else:
            target[key] = value
    
    return target


def memoize(func: Callable) -> Callable:
    """
    Декоратор для мемоизации функции
    
    Args:
        func: Функция для мемоизации
        
    Returns:
        Мемоизированная функция
    """
    cache = {}
    
    def wrapper(*args, **kwargs):
        # Создаем ключ на основе аргументов
        key = str(args) + str(kwargs)
        
        if key not in cache:
            cache[key] = func(*args, **kwargs)
        
        return cache[key]
    
    return wrapper


def throttle(limit: float) -> Callable:
    """
    Декоратор для ограничения частоты вызова функции
    
    Args:
        limit: Минимальный интервал между вызовами (секунды)
        
    Returns:
        Обернутая функция
    """
    last_called = 0
    
    def decorator(func: Callable) -> Callable:
        def wrapper(*args, **kwargs):
            nonlocal last_called
            
            current_time = time.time()
            elapsed = current_time - last_called
            
            if elapsed < limit:
                # Пропускаем вызов
                return None
            
            last_called = current_time
            return func(*args, **kwargs)
        
        return wrapper
    
    return decorator


def benchmark(func: Callable) -> Callable:
    """
    Декоратор для бенчмаркинга функции
    
    Args:
        func: Функция для бенчмаркинга
        
    Returns:
        Обернутая функция
    """
    def wrapper(*args, **kwargs):
        import timeit
        
        # Измеряем время выполнения
        timer = timeit.Timer(lambda: func(*args, **kwargs))
        
        # Выполняем 3 раза и берем лучшее время
        times = timer.repeat(repeat=3, number=1)
        best_time = min(times)
        
        # Выполняем функцию и получаем результат
        result = func(*args, **kwargs)
        
        print(f"{func.__name__}: Лучшее время выполнения: {best_time:.6f} секунд")
        
        return result
    
    return wrapper


def validate_config(config: Dict[str, Any], schema: Dict[str, Any]) -> ValidationResult:
    """
    Валидация конфигурации по схеме
    
    Args:
        config: Конфигурация для проверки
        schema: Схема валидации
        
    Returns:
        Результат валидации
    """
    result = ValidationResult()
    
    def validate_section(section_config, section_schema, path=""):
        for key, rules in section_schema.items():
            current_path = f"{path}.{key}" if path else key
            
            # Проверка обязательных полей
            if rules.get('required', False) and key not in section_config:
                result.add_error(f"Отсутствует обязательное поле: {current_path}")
                continue
            
            if key in section_config:
                value = section_config[key]
                
                # Проверка типа
                expected_type = rules.get('type')
                if expected_type:
                    if expected_type == 'int' and not isinstance(value, int):
                        result.add_error(f"Поле {current_path} должно быть целым числом")
                    elif expected_type == 'float' and not isinstance(value, (int, float)):
                        result.add_error(f"Поле {current_path} должно быть числом")
                    elif expected_type == 'str' and not isinstance(value, str):
                        result.add_error(f"Поле {current_path} должно быть строкой")
                    elif expected_type == 'bool' and not isinstance(value, bool):
                        result.add_error(f"Поле {current_path} должно быть булевым значением")
                    elif expected_type == 'list' and not isinstance(value, list):
                        result.add_error(f"Поле {current_path} должно быть списком")
                    elif expected_type == 'dict' and not isinstance(value, dict):
                        result.add_error(f"Поле {current_path} должно быть словарем")
                
                # Проверка диапазона
                if 'min' in rules and value < rules['min']:
                    result.add_error(f"Поле {current_path} должно быть не менее {rules['min']}")
                if 'max' in rules and value > rules['max']:
                    result.add_error(f"Поле {current_path} должно быть не более {rules['max']}")
                
                # Проверка длины для строк
                if isinstance(value, str):
                    if 'min_length' in rules and len(value) < rules['min_length']:
                        result.add_error(f"Поле {current_path} должно быть длиной не менее {rules['min_length']} символов")
                    if 'max_length' in rules and len(value) > rules['max_length']:
                        result.add_error(f"Поле {current_path} должно быть длиной не более {rules['max_length']} символов")
                
                # Проверка допустимых значений
                if 'allowed' in rules and value not in rules['allowed']:
                    result.add_error(f"Поле {current_path} должно быть одним из: {rules['allowed']}")
                
                # Рекурсивная проверка вложенных словарей
                if isinstance(value, dict) and 'schema' in rules:
                    validate_section(value, rules['schema'], current_path)
                
                # Рекурсивная проверка списков
                if isinstance(value, list) and 'item_schema' in rules:
                    for i, item in enumerate(value):
                        if isinstance(item, dict):
                            validate_section(item, rules['item_schema'], f"{current_path}[{i}]")
    
    validate_section(config, schema)
    return result


def create_default_config() -> Dict[str, Any]:
    """
    Создание конфигурации по умолчанию
    
    Returns:
        Конфигурация по умолчанию
    """
    return {
        'app': {
            'name': 'Niva Diagnostic Pro',
            'version': '1.0.0',
            'language': 'ru',
            'theme': 'dark',
            'auto_save': True,
            'auto_save_interval': 300,  # секунды
            'backup_enabled': True,
            'max_backups': 10,
        },
        'connection': {
            'type': 'auto',  # auto, bluetooth, usb, wifi
            'baudrate': 38400,
            'timeout': 2.0,
            'retry_count': 3,
            'auto_connect': False,
        },
        'diagnostics': {
            'full_scan_on_start': False,
            'auto_read_errors': True,
            'auto_clear_after_fix': False,
            'save_reports_automatically': True,
            'report_format': 'pdf',  # pdf, html, json
            'data_logging': True,
            'log_interval': 1000,  # мс
        },
        'vehicles': {
            'default_model': '21236',
            'remember_last_vehicle': True,
            'auto_detect_model': True,
        },
        'display': {
            'refresh_rate': 1000,  # мс
            'chart_history_length': 100,
            'show_grid': True,
            'animate_charts': True,
            'font_size': 9,
            'font_family': 'Segoe UI',
        },
        'alerts': {
            'enable_sound': True,
            'enable_popup': True,
            'critical_errors': True,
            'warning_errors': True,
            'info_messages': False,
            'notification_timeout': 5000,  # мс
        },
        'paths': {
            'reports_dir': 'reports',
            'backups_dir': 'backups',
            'logs_dir': 'logs',
            'profiles_dir': 'profiles',
            'export_dir': 'exports',
        },
    }


def merge_configs(default_config: Dict[str, Any], user_config: Dict[str, Any]) -> Dict[str, Any]:
    """
    Слияние конфигураций
    
    Args:
        default_config: Конфигурация по умолчанию
        user_config: Пользовательская конфигурация
        
    Returns:
        Объединенная конфигурация
    """
    result = deep_update(default_config.copy(), user_config)
    return result


def get_resource_path(relative_path: str) -> str:
    """
    Получение абсолютного пути к ресурсу
    
    Args:
        relative_path: Относительный путь
        
    Returns:
        Абсолютный путь
    """
    # Определяем базовую директорию
    if hasattr(sys, '_MEIPASS'):
        # Для собранного приложения PyInstaller
        base_path = sys._MEIPASS
    else:
        # Для разработки
        base_path = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    
    return os.path.join(base_path, relative_path)


def ensure_directory(path: str) -> bool:
    """
    Создание директории если она не существует
    
    Args:
        path: Путь к директории
        
    Returns:
        Успешность создания
    """
    try:
        os.makedirs(path, exist_ok=True)
        return True
    except Exception as e:
        print(f"Ошибка создания директории {path}: {e}")
        return False


def cleanup_old_files(directory: str, pattern: str, max_files: int = 10) -> int:
    """
    Очистка старых файлов в директории
    
    Args:
        directory: Директория для очистки
        pattern: Шаблон файлов
        max_files: Максимальное количество файлов для хранения
        
    Returns:
        Количество удаленных файлов
    """
    try:
        import glob
        
        files = glob.glob(os.path.join(directory, pattern))
        
        if len(files) <= max_files:
            return 0
        
        # Сортируем по времени изменения
        files.sort(key=os.path.getmtime)
        
        # Удаляем самые старые файлы
        files_to_delete = files[:len(files) - max_files]
        
        deleted_count = 0
        for file_path in files_to_delete:
            try:
                os.remove(file_path)
                deleted_count += 1
            except:
                pass
        
        return deleted_count
        
    except Exception as e:
        print(f"Ошибка очистки файлов: {e}")
        return 0


def get_disk_space_info(path: str = ".") -> Dict[str, Any]:
    """
    Получение информации о свободном месте на диске
    
    Args:
        path: Путь для проверки
        
    Returns:
        Информация о дисковом пространстве
    """
    try:
        import shutil
        
        total, used, free = shutil.disk_usage(path)
        
        return {
            'total_gb': round(total / (1024**3), 2),
            'used_gb': round(used / (1024**3), 2),
            'free_gb': round(free / (1024**3), 2),
            'used_percent': round(used / total * 100, 2) if total > 0 else 0,
            'free_percent': round(free / total * 100, 2) if total > 0 else 0,
        }
        
    except Exception as e:
        print(f"Ошибка получения информации о диске: {e}")
        return {
            'total_gb': 0,
            'used_gb': 0,
            'free_gb': 0,
            'used_percent': 0,
            'free_percent': 0,
        }


def format_error_message(error: Exception, context: str = "") -> str:
    """
    Форматирование сообщения об ошибке
    
    Args:
        error: Исключение
        context: Контекст ошибки
        
    Returns:
        Отформатированное сообщение
    """
    error_type = type(error).__name__
    error_msg = str(error)
    
    if context:
        return f"{context}: [{error_type}] {error_msg}"
    else:
        return f"[{error_type}] {error_msg}"


def is_valid_ip_address(address: str) -> bool:
    """
    Проверка валидности IP адреса
    
    Args:
        address: IP адрес для проверки
        
    Returns:
        Валидность адреса
    """
    import ipaddress
    
    try:
        ipaddress.ip_address(address)
        return True
    except ValueError:
        return False


def is_valid_port(port: int) -> bool:
    """
    Проверка валидности порта
    
    Args:
        port: Порт для проверки
        
    Returns:
        Валидность порта
    """
    return 1 <= port <= 65535


def calculate_distance(lat1: float, lon1: float, lat2: float, lon2: float) -> float:
    """
    Расчет расстояния между двумя точками (формула гаверсинусов)
    
    Args:
        lat1, lon1: Координаты первой точки
        lat2, lon2: Координаты второй точки
        
    Returns:
        Расстояние в километрах
    """
    # Конвертируем градусы в радианы
    lat1_rad = math.radians(lat1)
    lon1_rad = math.radians(lon1)
    lat2_rad = math.radians(lat2)
    lon2_rad = math.radians(lon2)
    
    # Разницы координат
    dlat = lat2_rad - lat1_rad
    dlon = lon2_rad - lon1_rad
    
    # Формула гаверсинусов
    a = math.sin(dlat / 2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2)**2
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))
    
    # Радиус Земли в километрах
    radius_km = 6371.0
    
    return radius_km * c


def normalize_value(value: float, min_val: float, max_val: float) -> float:
    """
    Нормализация значения в диапазон [0, 1]
    
    Args:
        value: Значение для нормализации
        min_val: Минимальное значение
        max_val: Максимальное значение
        
    Returns:
        Нормализованное значение
    """
    if max_val == min_val:
        return 0.0
    
    normalized = (value - min_val) / (max_val - min_val)
    return max(0.0, min(1.0, normalized))


def denormalize_value(normalized: float, min_val: float, max_val: float) -> float:
    """
    Денормализация значения из диапазона [0, 1]
    
    Args:
        normalized: Нормализованное значение
        min_val: Минимальное значение
        max_val: Максимальное значение
        
    Returns:
        Денормализованное значение
    """
    return normalized * (max_val - min_val) + min_val


def create_color_gradient(value: float, min_val: float = 0.0, max_val: float = 1.0) -> str:
    """
    Создание цвета градиента на основе значения
    
    Args:
        value: Значение для цветового кодирования
        min_val: Минимальное значение (зеленый)
        max_val: Максимальное значение (красный)
        
    Returns:
        Цвет в формате HEX
    """
    # Нормализуем значение
    normalized = normalize_value(value, min_val, max_val)
    
    # Создаем градиент от зеленого через желтый к красному
    if normalized < 0.5:
        # Зеленый -> Желтый
        r = int(255 * (normalized * 2))
        g = 255
        b = 0
    else:
        # Желтый -> Красный
        r = 255
        g = int(255 * (2 - normalized * 2))
        b = 0
    
    # Ограничиваем значения
    r = max(0, min(255, r))
    g = max(0, min(255, g))
    b = max(0, min(255, b))
    
    return f"#{r:02x}{g:02x}{b:02x}"


def format_bytes_human_readable(bytes_count: int) -> str:
    """
    Форматирование размера в байтах в человекочитаемый вид
    
    Args:
        bytes_count: Количество байт
        
    Returns:
        Отформатированная строка
    """
    suffixes = ['Б', 'КБ', 'МБ', 'ГБ', 'ТБ', 'ПБ']
    
    if bytes_count == 0:
        return '0 Б'
    
    i = 0
    while bytes_count >= 1024 and i < len(suffixes) - 1:
        bytes_count /= 1024
        i += 1
    
    if i == 0:
        return f"{bytes_count:.0f} {suffixes[i]}"
    else:
        return f"{bytes_count:.2f} {suffixes[i]}"


def generate_unique_id(length: int = 16) -> str:
    """
    Генерация уникального идентификатора
    
    Args:
        length: Длина идентификатора
        
    Returns:
        Уникальный идентификатор
    """
    import uuid
    import hashlib
    
    # Генерируем UUID
    unique_str = str(uuid.uuid4())
    
    # Хэшируем для получения нужной длины
    hash_obj = hashlib.sha256(unique_str.encode())
    hex_digest = hash_obj.hexdigest()
    
    # Обрезаем до нужной длины
    return hex_digest[:length]


def parse_version_string(version_str: str) -> Tuple[int, int, int]:
    """
    Парсинг строки версии
    
    Args:
        version_str: Строка версии (например, "1.2.3")
        
    Returns:
        Кортеж (major, minor, patch)
    """
    parts = version_str.split('.')
    
    major = int(parts[0]) if len(parts) > 0 else 0
    minor = int(parts[1]) if len(parts) > 1 else 0
    patch = int(parts[2]) if len(parts) > 2 else 0
    
    return major, minor, patch


def compare_versions(version1: str, version2: str) -> int:
    """
    Сравнение версий
    
    Args:
        version1: Первая версия
        version2: Вторая версия
        
    Returns:
        -1 если version1 < version2
        0 если version1 == version2
        1 если version1 > version2
    """
    v1_parts = parse_version_string(version1)
    v2_parts = parse_version_string(version2)
    
    if v1_parts < v2_parts:
        return -1
    elif v1_parts > v2_parts:
        return 1
    else:
        return 0


def get_application_info() -> Dict[str, Any]:
    """
    Получение информации о приложении
    
    Returns:
        Словарь с информацией
    """
    info = {
        'name': 'Niva Diagnostic Pro',
        'version': '1.0.0',
        'description': 'Профессиональная диагностика Chevrolet Niva',
        'author': 'Диагностический Центр',
        'copyright': '© 2024 Все права защищены',
        'website': 'https://github.com/niva-diagnostic',
        'license': 'MIT',
        'python_version': sys.version,
        'platform': sys.platform,
        'start_time': datetime.datetime.now().isoformat(),
    }
    
    return info


def create_application_signature() -> str:
    """
    Создание цифровой подписи приложения
    
    Returns:
        Цифровая подпись
    """
    import hashlib
    
    app_info = get_application_info()
    
    # Создаем строку для хэширования
    signature_data = f"{app_info['name']}{app_info['version']}{app_info['start_time']}"
    
    # Вычисляем хэш
    hash_obj = hashlib.sha256(signature_data.encode())
    signature = hash_obj.hexdigest()
    
    return signature


def verify_application_integrity(expected_signature: str) -> bool:
    """
    Проверка целостности приложения
    
    Args:
        expected_signature: Ожидаемая цифровая подпись
        
    Returns:
        Результат проверки
    """
    current_signature = create_application_signature()
    return current_signature == expected_signature


# Экспортируемые функции
__all__ = [
    'Units',
    'ValidationResult',
    'VehicleInfo',
    'calculate_checksum',
    'hex_string_to_bytes',
    'bytes_to_hex_string',
    'parse_hex_response',
    'convert_units',
    'format_number',
    'parse_dtc_code',
    'dtc_to_description',
    'validate_vin',
    'calculate_vin_checksum',
    'create_vehicle_profile',
    'save_vehicle_profile',
    'load_vehicle_profile',
    'calculate_fuel_consumption',
    'analyze_sensor_data',
    'detect_anomalies',
    'interpolate_missing_values',
    'smooth_data',
    'create_timestamp',
    'time_function',
    'retry_on_exception',
    'format_duration',
    'get_system_info',
    'create_backup',
    'calculate_file_hash',
    'find_latest_backup',
    'restore_from_backup',
    'compress_data',
    'decompress_data',
    'generate_report_filename',
    'safe_filename',
    'get_file_size_string',
    'list_serial_ports',
    'list_bluetooth_devices',
    'calculate_engine_efficiency',
    'predict_fault_probability',
    'create_data_export',
    'flatten_dict',
    'deep_update',
    'memoize',
    'throttle',
    'benchmark',
    'validate_config',
    'create_default_config',
    'merge_configs',
    'get_resource_path',
    'ensure_directory',
    'cleanup_old_files',
    'get_disk_space_info',
    'format_error_message',
    'is_valid_ip_address',
    'is_valid_port',
    'calculate_distance',
    'normalize_value',
    'denormalize_value',
    'create_color_gradient',
    'format_bytes_human_readable',
    'generate_unique_id',
    'parse_version_string',
    'compare_versions',
    'get_application_info',
    'create_application_signature',
    'verify_application_integrity',
]